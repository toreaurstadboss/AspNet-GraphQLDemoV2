@page "/mountainsPaginated"
@using Blazorise
@using Blazorise.DataGrid
@using System.Text.Json
@using MountainsClientDemoV2
@using MountainsDemo.PresentationModels
@using System.Collections.ObjectModel
@*@using MountainsClientDemoV2*@
@*@using MountainsClientDemoV2
*@

<PageTitle>Index</PageTitle>

<h5>
    Norwegian Mountains V2 <Figure Size="FigureSize.Is24x24" TextAlignment="TextAlignment.End">
        <FigureImage Source="images/mountain.png" AlternateText="mountain image logo" Rounded />
        <FigureCaption>Tallest moutains and hills in Norwegian municipalities (kommuner)</FigureCaption>
    </Figure>
</h5>


<Card></Card>
Clientside : .net 6 Blazor wasm with StrawberryShake to access GraphQL Server
Backend: HotChocolate GraphQL server
This page uses a paginated query to fetch data from the server using cursor based pagination (and not offset based pagination).

<DataGrid @ref="MountainsDataPaginatedGrid"
          Data="@mountainsResult"          
          TItem="MountainItem"
          Filterable="true"
          FilterMethod="DataGridFilterMethod.Contains"
          ShowPager="false"
          @bind-SelectedRow="@selectedMountain"
          ShowPageSizes="true"
          Editable="true"
          Striped="true"
          EditMode="DataGridEditMode.Popup"
          PageSizeChanged="OnPageSizeChangedAsync"
          PageChanged="OnPageChangedAsync"
          RowUpdating="OnRowUpdatingAsync"
          RowUpdated="OnRowUpdatedAsync"          
          Hoverable="true"
          Responsive="true">
    <ChildContent>
<FirstPageButtonTemplate>
    <Button>First page</Button> <!-- TODO : implement custom control of the paging ! -->
</FirstPageButtonTemplate>
<FirstPageButtonTemplate>
    <Button>Last page</Button>
</FirstPageButtonTemplate>
<PreviousPageButtonTemplate>
    <Button>Previous page</Button>
</PreviousPageButtonTemplate>
<NextPageButtonTemplate>
    Next page
</NextPageButtonTemplate>
        <DataGridCommandColumn TItem="MountainItem" Width="200">
              <EditCommandTemplate>
               <Button Margin="Margin.Is1" Color="Color.Success" Clicked="@context.Clicked">Edit</Button>
            </EditCommandTemplate>
            <DeleteCommandTemplate>
                <Button Margin="Margin.Is1" Color="Color.Danger" Clicked="@context.Clicked">Delete</Button>
            </DeleteCommandTemplate>
        </DataGridCommandColumn>
        <DataGridColumn TItem="MountainItem" Field="Id" Caption="Id" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="OfficialName" Caption="OfficialName" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="MetresAboveSeaLevel" Caption="MetresAboveSeaLevel" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="PrimaryFactor" Caption="PrimaryFactor" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="Municipality" Caption="Municipality" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="ReferencePoint" Caption="ReferencePoint" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="County" Caption="County" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="Comments" Caption="Comments" Sortable="true" Displayable="true" Editable="true">
            <EditTemplate>
                <Label><br /><b>@context.Item.OfficialName</b></Label>
                <TextEdit TValue="string"
                          Text="@((string)context.CellValue)"
                          TextChanged="@( v => {                                                   
                                                    context.CellValue = v;
                                                    context.UpdateCell( nameof( MountainItem.Comments ), v);
                                              })" />
            </EditTemplate>
        </DataGridColumn>
    </ChildContent>
    <EmptyTemplate>
        <div class="box">
            No mountains were found.
        </div>
    </EmptyTemplate>
    <LoadingTemplate>
        <div class="box">
            <progress class="progress is-small is-primary" max="100" />
        </div>
    </LoadingTemplate>
  

</DataGrid>

@code {

    [Inject] private ILogger<Index> log { get; init; }

    [Inject] private MountainsDemoV2 client { get; set; }

    private MountainItem? selectedMountain;

    private IList<MountainItem>? mountainsResult;

    private int startIndexGetMountainsPaginatedData;

    private DataGrid<MountainItem>? MountainsDataPaginatedGrid;

    protected void OnSelectedRowChanged(MountainItem model)
    {
        selectedMountain = model;
        log.LogInformation($"selected row (mountain) changed - current id is now: {model.Id}");
    }

    protected override async Task OnParametersSetAsync()
    {
        await ReloadMountainData(5);
    }

    public async Task OnPageSizeChangedAsync(int pageSize){
        if (MountainsDataPaginatedGrid == null){
            return;
        }      
        await ReloadMountainData(pageSize);
    }

    public async Task OnPageChangedAsync(DataGridPageChangedEventArgs pageChanged){
        if (MountainsDataPaginatedGrid == null){
            return;
        }
        int pageSize = MountainsDataPaginatedGrid?.PageSize ?? 5;
        await ReloadMountainData(pageSize);
    }

    public void OnRowUpdatingAsync(CancellableRowChange<MountainItem, Dictionary<string, object>> e){
        MountainItem? mountain = e?.Item; 
        if (mountain != null){
            selectedMountain = mountain; 
        }
        else {
            selectedMountain = null;
        }
    }

    public void OnRowUpdatedAsync(SavedRowItem<MountainItem, Dictionary<string, object>> e)
    {
        // This handler is fired after i hit the save button provided by internal edit functionality.
        MountainItem mountain = e.Item;
        string? comments = e.Values["Comments"] as string; // This gives me old value.
                                                           //TODO: Persist the comments for mountain via a mutation to the GraphQL Server
        if (selectedMountain == null || string.IsNullOrEmpty(comments)){
            return;
        }
        else if (selectedMountain.Id >= 1) {
            client.UpdateMountainComment.ExecuteAsync(selectedMountain.Id, comments);
            StateHasChanged();
        }
    }

    private async Task ReloadMountainData(int pageSize){
        int pageIndex = 0;
        if(MountainsDataPaginatedGrid != null){
            pageIndex = MountainsDataPaginatedGrid.CurrentPage;
        }
        startIndexGetMountainsPaginatedData = pageIndex * pageSize;     
        var mountainsFromServerPaginated = await client.MountainsPage.ExecuteAsync(pageSize, startIndexGetMountainsPaginatedData);
        mountainsResult = mountainsFromServerPaginated!.Data!.MountainsPage!.Items!.Select(e => new MountainItem(e)).ToList();

        if (MountainsDataPaginatedGrid != null){
            MountainsDataPaginatedGrid.TotalItems = 100; // mountainsFromServerPaginated.Data.MountainsPage.TotalCount;
        }

        Console.WriteLine("Page info:" + JsonSerializer.Serialize(mountainsFromServerPaginated.Data.MountainsPage.PageInfo));

    }

}
