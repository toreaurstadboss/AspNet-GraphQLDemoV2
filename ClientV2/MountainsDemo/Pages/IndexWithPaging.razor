@page "/mountainsPaginated"
@using Blazorise
@using Blazorise.DataGrid
@using System.Text.Json
@using MountainsClientDemoV2
@using MountainsDemo.PresentationModels
@using System.Collections.ObjectModel
@*@using MountainsClientDemoV2*@
@*@using MountainsClientDemoV2
*@

<PageTitle>Index</PageTitle>

<h5>
    Norwegian Mountains V2 <Figure Size="FigureSize.Is24x24" TextAlignment="TextAlignment.End">
        <FigureImage Source="images/mountain.png" AlternateText="mountain image logo" Rounded />
        <FigureCaption>Tallest moutains and hills in Norwegian municipalities (kommuner)</FigureCaption>
    </Figure>
</h5>


<Card></Card>
Clientside : .net 6 Blazor wasm with StrawberryShake to access GraphQL Server
Backend: HotChocolate GraphQL server
This page uses a paginated query to fetch data from the server using offset based pagination (and not cursor based pagination) in GraphQL.

<DataGrid @ref="MountainsDataPaginatedGrid"
          Data="@mountainsResult"          
          TItem="MountainItem"
          Filterable="false"
          FilterMethod="DataGridFilterMethod.Contains"
          ShowPager="false"
          @bind-SelectedRow="@selectedMountain"
          ShowPageSizes="true"
          Editable="true"
          Striped="true"
          EditMode="DataGridEditMode.Popup"
          PageSizeChanged="OnPageSizeChangedAsync"
          RowUpdating="OnRowUpdatingAsync"
          RowUpdated="OnRowUpdatedAsync"          
          Hoverable="true"
          Responsive="true">
    <ChildContent>
        <FirstPageButtonTemplate>
            <Button Class="page-item" @onclick="@(async () => await ReloadMountainData(pageSizeGetMountainsPaginatedData, 0))" Color="Color.Link">First</Button> <!-- TODO : implement custom control of the paging ! -->
        </FirstPageButtonTemplate>        
        <PreviousPageButtonTemplate @onclick="@(async () => await ReloadMountainData(pageSizeGetMountainsPaginatedData, --currentPageMountainsPaginatedData))">
            <Button Class="page-item" Color="Color.Link">Prev</Button>
        </PreviousPageButtonTemplate>
        <NextPageButtonTemplate>
            <Button Class="page-item" @onclick="@(async () => await ReloadMountainData(pageSizeGetMountainsPaginatedData, ++currentPageMountainsPaginatedData))" Color="Color.Link">Next</Button>
        </NextPageButtonTemplate>
         <LastPageButtonTemplate @onclick="@(async () => await ReloadMountainData(pageSizeGetMountainsPaginatedData, GetLastPageIndex()))">
            <Button Class="page-item" Color="Color.Link">Last</Button>
        </LastPageButtonTemplate>
        <DataGridCommandColumn TItem="MountainItem" Width="200">
              <EditCommandTemplate>
               <Button Margin="Margin.Is1" Color="Color.Success" Clicked="@context.Clicked" Outline>Edit</Button>
            </EditCommandTemplate>
            <DeleteCommandTemplate>
                <Button Margin="Margin.Is1" Color="Color.Danger" Clicked="@context.Clicked" Outline>Delete</Button>
            </DeleteCommandTemplate>
        </DataGridCommandColumn>
        <DataGridColumn TItem="MountainItem" Field="Id" Caption="Id" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="OfficialName" Caption="OfficialName" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="MetresAboveSeaLevel" Caption="MetresAboveSeaLevel" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="PrimaryFactor" Caption="PrimaryFactor" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="Municipality" Caption="Municipality" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="ReferencePoint" Caption="ReferencePoint" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="County" Caption="County" Sortable="true" Displayable="true" />
        <DataGridColumn TItem="MountainItem" Field="Comments" Caption="Comments" Sortable="true" Displayable="true" Editable="true">
            <EditTemplate>
                <Label><br /><b>@context.Item.OfficialName</b></Label>
                <TextEdit TValue="string"
                          Text="@((string)context.CellValue)"
                          TextChanged="@( v => {                                                   
                                                    context.CellValue = v;
                                                    context.UpdateCell( nameof( MountainItem.Comments ), v);
                                              })" />
            </EditTemplate>
        </DataGridColumn>
    </ChildContent>
    <EmptyTemplate>
        <div class="box">
            No mountains were found.
        </div>
    </EmptyTemplate>
    <LoadingTemplate>
        <div class="box">
            <progress class="progress is-small is-primary" max="100" />
        </div>
    </LoadingTemplate>        

</DataGrid>

<ul class="pagination">
 @{
     
 }
 @foreach (var i in Enumerable.Range(GetSuitableFirstPage(), GetPageRangeAvailable())){
    <li class="page-item"><a onclick="@(async () => await ReloadMountainData(pageSizeGetMountainsPaginatedData, @i))" title="Go to page @i" style="color:black;cursor:pointer;font-weight:@GetFontWeightForPage(@i)" class="page-link">@i</a></li>
 }
</ul>
<div class="inline-block">
    @(startIndexMountainsPaginatedData) - @(Math.Min(startIndexMountainsPaginatedData+pageSizeGetMountainsPaginatedData, totalCountMountainsPaginatedData)) of @totalCountMountainsPaginatedData items
</div>

@code {

    [Inject] private ILogger<Index> log { get; init; }

    [Inject] private MountainsDemoV2 client { get; set; }

    private MountainItem? selectedMountain;

    private IList<MountainItem>? mountainsResult;

    private int startIndexMountainsPaginatedData;

    private int totalCountMountainsPaginatedData;

    private int currentPageMountainsPaginatedData;

    private int pageSizeGetMountainsPaginatedData = 5;

    private DataGrid<MountainItem>? MountainsDataPaginatedGrid;

    private string GetFontWeightForPage(int pageIndex){
        return pageIndex != currentPageMountainsPaginatedData ? "normal" : "bold";    
    }

    private int GetSuitableFirstPage(){
        if (GetLastPageIndex() - 10 < currentPageMountainsPaginatedData){
            return Math.Max(0, currentPageMountainsPaginatedData - 4);
        }
        return Math.Max(0, currentPageMountainsPaginatedData - 4);
    }

    private int GetPageRangeAvailable(){
        int lastPage = GetLastPageIndex();
        int pageRange = 1;
        if (currentPageMountainsPaginatedData < lastPage - 10){
            pageRange = 10;
        }
        else if (lastPage - currentPageMountainsPaginatedData < 10) {
            pageRange = Math.Max(1, GetLastPageIndex() - GetSuitableFirstPage() + 1);
        }
        //StateHasChanged();
        return pageRange;
    }

    private int GetLastPageIndex(){
        if (totalCountMountainsPaginatedData > 0 && pageSizeGetMountainsPaginatedData > 0){
            int lastPage = (totalCountMountainsPaginatedData / pageSizeGetMountainsPaginatedData) - 1; //0-indexed pages so need to subtract 1
            if (((lastPage+1) * pageSizeGetMountainsPaginatedData) < totalCountMountainsPaginatedData){
                lastPage++;
            }
            if (lastPage > 0){
                return lastPage;
            }
        }
        return 0;
    }

    protected void OnSelectedRowChanged(MountainItem model)
    {
        selectedMountain = model;
        log.LogInformation($"selected row (mountain) changed - current id is now: {model.Id}");
    }

    protected override async Task OnParametersSetAsync()
    {
        await ReloadMountainData(5, 0);
    }

    public async Task OnPageSizeChangedAsync(int pageSize){
        if (MountainsDataPaginatedGrid == null){
            return;
        }
        pageSizeGetMountainsPaginatedData = pageSize;
        await ReloadMountainData(pageSize, 0);
    }

    public void OnRowUpdatingAsync(CancellableRowChange<MountainItem, Dictionary<string, object>> e){
        MountainItem? mountain = e?.Item; 
        if (mountain != null){
            selectedMountain = mountain; 
        }
        else {
            selectedMountain = null;
        }
    }

    public void OnRowUpdatedAsync(SavedRowItem<MountainItem, Dictionary<string, object>> e)
    {
        // This handler is fired after i hit the save button provided by internal edit functionality.
        MountainItem mountain = e.Item;
        string? comments = e.Values["Comments"] as string; // This gives me old value.
                                                           //TODO: Persist the comments for mountain via a mutation to the GraphQL Server
        if (selectedMountain == null || string.IsNullOrEmpty(comments)){
            return;
        }
        else if (selectedMountain.Id >= 1) {
            client.UpdateMountainComment.ExecuteAsync(selectedMountain.Id, comments);
            StateHasChanged();
        }
    }

    private async Task ReloadMountainData(int pageSize, int pageIndex){
        if (pageIndex < 0){
            pageIndex = 0;
        }
        if (pageIndex > GetLastPageIndex()){
            pageIndex = GetLastPageIndex();
        }
        Console.WriteLine("Inside ReloadMountainsData");
        currentPageMountainsPaginatedData = pageIndex;
        startIndexMountainsPaginatedData = pageIndex * pageSize;     
        var mountainsFromServerPaginated = await client.MountainsPage.ExecuteAsync(pageSize, startIndexMountainsPaginatedData);
        mountainsResult = mountainsFromServerPaginated!.Data!.MountainsPage!.Items!.Select(e => new MountainItem(e)).ToList();

        totalCountMountainsPaginatedData = mountainsFromServerPaginated!.Data!.MountainsPage!.TotalCount;

        Console.WriteLine("Page info:" + JsonSerializer.Serialize(mountainsFromServerPaginated.Data.MountainsPage.PageInfo));
        StateHasChanged();
    }

}
